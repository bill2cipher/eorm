eorm
=====

An OTP application

Build
-----

    $ rebar3 compile


TODO LIST
---------
1. dynamic config
2. dets 重复插入导致之前的操作丢失
3. flush 策略更改
4. proc_table进程重启导致eorm_server丢失监控
5. 增加异步接口
6. 缓存淘汰策略
7. 更改依赖次序
8. 删除了update操作，可以删除key_table了
9. eorm作为一个独立节点启动，读取配置文件；而不是作为一个类库

设计目标:
-----
1. 提供存入和删除数据的操作，操作对象是erlang term，自动转化为mysql语句进行插入或者删除；
2. 容灾：
2.1 保证数据能够入库，在数据库出问题的情况下，能够缓存数据操作，等待恢复后再执行操作;
2.2 或者是仅仅返回mysql操作结果，提供一个erlang term到sql语句的转换；
3. 稳定性：不会崩溃，或者崩溃之后快速恢复，不影响操作；而且反馈时间能够稳定在一个时间点以内；
任何时候服务崩溃之后存入dets的数据都是可以恢复的；
4. 缓存：游戏服内部应该有缓存，不再需要eorm做缓存； ----或者更大的缓存,在淘汰缓存的时候还需要
查看时候是否有正在进行的对该数据的操作，如果有不能淘汰。


设计方案：
---------
1. dets主要缓存，随后定时刷如db；
优点：速度快，可以迅速反馈；
缺点：刷入db时会暂停服务；无法及时发现数据问题导致的入库失败，会一直入库，直到次数上限；
解决flush延迟反馈问题需要引入双dets，但是会导致重启是无法确定两个dets表的刷入次序；可以引入
3个dets来解决双dets导致的刷入次序问题；因为有db写入失败情况，所以双dets需要合并新旧dets的数据
解决数据一致性问题，并且是将新dets插入旧dets；

2. db主要缓存，在第一次操作失败，并且是数据库连接的情况下刷入dets，
等待下次刷入，如果是其它问题，直接返回错误给调用者：
优点：减少对dets的依赖，能够快速发现数据问题导致的无法写入；
缺点：db速度慢，增加单次调用的反馈时间；无法保证对同一key操作的次序，无法保证数据一致性;
而且作为外部服务，mysql的响应时间稳定性不知，无法提供稳定的响应时间服务；